import { DynamicRepository } from '../../dynamic-api/repositories/dynamic.repository';
import { MetadataCacheService } from '../../../infrastructure/cache/services/metadata-cache.service';
import { QueryBuilderService } from '../../../infrastructure/query-builder/query-builder.service';
import { TableHandlerService } from '../../table-management/services/table-handler.service';
import { QueryEngine } from '../../../infrastructure/query-engine/services/query-engine.service';
import { RouteCacheService } from '../../../infrastructure/cache/services/route-cache.service';
import { StorageConfigCacheService } from '../../../infrastructure/cache/services/storage-config-cache.service';
import { AiConfigCacheService } from '../../../infrastructure/cache/services/ai-config-cache.service';
import { SystemProtectionService } from '../../dynamic-api/services/system-protection.service';
import { TableValidationService } from '../../dynamic-api/services/table-validation.service';
import { SwaggerService } from '../../../infrastructure/swagger/services/swagger.service';
import { GraphqlService } from '../../graphql/services/graphql.service';
import { TDynamicContext } from '../../../shared/interfaces/dynamic-context.interface';

type ValidationError = { step: string; error: string; retryable: boolean };

export interface TableRepoDeps {
  metadataCacheService: MetadataCacheService;
  queryBuilder: QueryBuilderService;
  tableHandlerService: TableHandlerService;
  queryEngine: QueryEngine;
  routeCacheService: RouteCacheService;
  storageConfigCacheService: StorageConfigCacheService;
  aiConfigCacheService: AiConfigCacheService;
  systemProtectionService: SystemProtectionService;
  tableValidationService: TableValidationService;
  swaggerService: SwaggerService;
  graphqlService: GraphqlService;
}

export function createTableDefinitionRepository(deps: TableRepoDeps, context: TDynamicContext) {
  return new DynamicRepository({
    context,
    tableName: 'table_definition',
    queryBuilder: deps.queryBuilder,
    tableHandlerService: deps.tableHandlerService,
    queryEngine: deps.queryEngine,
    routeCacheService: deps.routeCacheService,
    storageConfigCacheService: deps.storageConfigCacheService,
    aiConfigCacheService: deps.aiConfigCacheService,
    metadataCacheService: deps.metadataCacheService,
    systemProtectionService: deps.systemProtectionService,
    tableValidationService: deps.tableValidationService,
    bootstrapScriptService: undefined,
    redisPubSubService: undefined,
    swaggerService: deps.swaggerService,
    graphqlService: deps.graphqlService,
  });
}

export function collectTableDataValidationErrors(tableData: any, queryBuilder: QueryBuilderService): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!tableData.name || tableData.name.trim() === '') {
    errors.push({ step: 'validateTableData', error: 'Table name is required', retryable: false });
  }

  if (/[A-Z]/.test(tableData.name)) {
    errors.push({ step: 'validateTableData', error: 'Table name must be lowercase', retryable: false });
  }

  if (!/^[a-z0-9_]+$/.test(tableData.name)) {
    errors.push({ step: 'validateTableData', error: 'Table name must be snake_case (a-z, 0-9, _)', retryable: false });
  }

  if (tableData.name?.startsWith('_')) {
    errors.push({ step: 'validateTableData', error: 'Table name cannot start with an underscore (_)', retryable: false });
  }

  if (!tableData.columns || tableData.columns.length === 0) {
    errors.push({ step: 'validateTableData', error: 'Table must have at least one column', retryable: false });
  }

  const idColumn = tableData.columns?.find((col: any) => col.name === 'id' && col.isPrimary);
  if (!idColumn) {
    errors.push({ step: 'validateTableData', error: 'Table must have an \"id\" column with isPrimary=true', retryable: false });
  }

  if (idColumn && !idColumn.type) {
    const isMongoDB = queryBuilder.isMongoDb();
    idColumn.type = isMongoDB ? 'uuid' : 'int';
  }

  if (idColumn && idColumn.type) {
    const isMongoDB = queryBuilder.isMongoDb();
    if (isMongoDB && idColumn.type !== 'uuid') {
      errors.push({ step: 'validateTableData', error: `MongoDB requires id column to be type \"uuid\", not \"${idColumn.type}\"`, retryable: false });
    }
  }

  const primaryCount = tableData.columns?.filter((col: any) => col.isPrimary).length;
  if (primaryCount !== 1) {
    errors.push({ step: 'validateTableData', error: 'Only one column can have isPrimary=true', retryable: false });
  }

  const hasCreatedAt = tableData.columns?.some((col: any) => col.name === 'createdAt');
  const hasUpdatedAt = tableData.columns?.some((col: any) => col.name === 'updatedAt');
  if (hasCreatedAt || hasUpdatedAt) {
    errors.push({
      step: 'validateTableData',
      error: 'createdAt and updatedAt columns are auto-generated by system. Do NOT include them in columns array.',
      retryable: false,
    });
  }

  return errors;
}

export function collectRelationValidationErrors(relations: any[]): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!relations) {
    return errors;
  }

  for (const rel of relations) {
    if (rel.type === 'one-to-many' && !rel.inversePropertyName) {
      errors.push({
        step: 'validateTableData',
        error: `One-to-many relation '${rel.propertyName}' must have inversePropertyName`,
        retryable: false,
      });
    }
    if (rel.type === 'many-to-many' && !rel.inversePropertyName) {
      errors.push({
        step: 'validateTableData',
        error: `Many-to-many relation '${rel.propertyName}' must have inversePropertyName`,
        retryable: false,
      });
    }
  }

  return errors;
}

