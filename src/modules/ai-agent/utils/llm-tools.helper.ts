interface ToolDefinition {
  name: string;
  description: string;
  parameters: {
    type: string;
    properties: Record<string, any>;
    required?: string[];
  };
}

export const COMMON_TOOLS: ToolDefinition[] = [
  {
    name: 'get_table_details',
    description: `Purpose → load the full schema (columns, relations, indexes, constraints, table ID) for one or multiple tables.

CRITICAL - Call ONCE per table, reuse schema for subsequent operations.

CRITICAL - NEVER query all tables. ALWAYS filter first using find_records on table_definition, then call get_table_details only for filtered subset. Max 5 tables per call.

Use when:
- Preparing create/update payloads that must match schema exactly (call ONCE, then reuse)
- Investigating relation structure or constraints (call ONCE, then reuse)
- Need to compare multiple tables' schemas (call once with array of all table names, but filter first if user specified criteria)
- Need to check if tables have relations (call ONCE, then reuse)
- Need to get table ID (e.g., for relations, updates) - the metadata includes the table ID field

Skip when:
- You already called get_table_details for this table earlier in this response - reuse the previous result
- User asks for "non-system tables" but you haven't filtered yet → call find_records({"table":"table_definition","fields":"name,isSystem","where":{"isSystem":{"_eq":false}},"limit":0}) first to filter

Inputs:
- tableName (required) → array of table names (case-sensitive). For single table, use array with 1 element: ["user_definition"]
- forceRefresh (optional) true to reload metadata

Response format:
{
  [tableName: string]: {
    name: string;
    description?: string;
    isSingleRecord?: boolean;
    id?: number;
    isSystem?: boolean;
    uniques?: any[];
    indexes?: any[];
    columns: {
      fields: ["name", "type", "isNullable", "isPrimary", "isGenerated", "defaultValue", "options", "description"];
      data: [
        ["id", "int", false, true, true, null, null, null],
        ["name", "varchar", false, false, false, null, null, "Product name"],
        ...
      ]
    };
    relations: {
      fields: ["propertyName", "type", "targetTableName", "isNullable", "inversePropertyName", "foreignKeyColumn", "description"];
      data: [
        ["category", "many-to-one", "categories", true, null, "categoryId", null],
        ...
      ]
    };
  };
}

**How to parse compact format:**
- columns.data[i][j] = value of columns.fields[j] for column i
- Example: columns.data[0][0] = "id" (name), columns.data[0][1] = "int" (type)
- relations.data[i][j] = value of relations.fields[j] for relation i
- Example: relations.data[0][0] = "category" (propertyName), relations.data[0][2] = "categories" (targetTableName)
- Use fields array to map indices: fields[0]=name, fields[1]=type, etc.

**Important Field Definitions:**

**Table-level fields:**
- isSystem (boolean): If true, this is a system table (e.g., table_definition, column_definition, relation_definition). System tables are critical for system operation and should NOT be deleted or heavily modified. If false, this is a user-created table that can be safely deleted.
- isSingleRecord (boolean): If true, this table is designed to store only ONE record (singleton pattern). Examples: system settings, global configuration. If false or missing, table can store multiple records.

**Column-level fields:**
- isPrimary (boolean): If true, this column is the primary key (unique identifier for each record). Each table MUST have exactly one column with isPrimary=true. Primary key values are unique and cannot be null.
- isNullable (boolean): If true, this column can contain NULL values. If false, this column is REQUIRED and cannot be null (NOT NULL constraint).
- isGenerated (boolean): If true, this column value is auto-generated by the database (e.g., auto-increment ID, UUID, timestamp). You should NOT provide values for generated columns when creating records.
- isUnique (boolean): If true, this column has a unique constraint - each value must be unique across all records in the table. Cannot have duplicate values.
- defaultValue (any): The default value assigned to this column if no value is provided when creating a record. If isGenerated=true, the database generates the value automatically.

**Relation-level fields:**
- isNullable (boolean): If true, the foreign key column can be NULL (relation is optional). If false, the foreign key is REQUIRED (relation is mandatory).
- type: Relation type - "many-to-one" (many records in this table reference one record in target), "one-to-many" (one record in this table has many in target), "one-to-one" (one-to-one relationship), "many-to-many" (many-to-many via junction table).

CRITICAL - Relations Format for Create/Update:
- When creating or updating records with relations, you MUST use propertyName from relations array
- Format for SQL databases (PostgreSQL, MySQL, etc.): {[propertyName]: {id: value}}
  Example: {"customer": {id: 1}} or {"category": {id: 19}}
- Format for MongoDB: {[propertyName]: {_id: value}}
  Example: {"customer": {_id: "507f1f77bcf86cd799439011"}}
- NEVER use foreignKeyColumn directly (e.g., "customer_id", "customerId") - it's only for reference
- NEVER use simple ID value (e.g., {"customer": 1}) - always use object format with id/_id
- For many-to-many relations, use array format: {[propertyName]: [{id: 1}, {id: 2}]} or {[propertyName]: [{_id: "..."}, {_id: "..."}]}
- Example: If relations array shows {propertyName: "customer", type: "many-to-one", targetTableName: "customers"}, use {"customer": {id: 1}} NOT {"customer_id": 1} or {"customerId": 1} or {"customer": 1}

Note: To check if a table has relations, check if relations array is empty [] or missing → no relations; if has items → has relations.
CRITICAL: Always check relations array to see available propertyName values before creating/updating records with relations.

Examples:
Single: {"tableName":["user_definition"]}
Multiple: {"tableName":["product","category","order"]}`,
    parameters: {
      type: 'object',
      properties: {
        tableName: {
          type: 'array',
          items: {
            type: 'string',
          },
          description: 'REQUIRED. Array of table names. For single table, use array with 1 element: ["user_definition"]. For multiple tables: ["product", "category", "order"].',
        },
        forceRefresh: {
          type: 'boolean',
          description: 'Optional. Set to true to reload metadata from database. Default: false.',
          default: false,
        },
      },
      required: ['tableName'],
    },
  },
  {
    name: 'get_hint',
    description: `Purpose → General guidance for system operations. Use for general workflows, not tool-specific rules.

CRITICAL - Check System Prompt First:
- BEFORE calling this tool, check if your system prompt contains a "RELEVANT WORKFLOWS & RULES" section
- If "RELEVANT WORKFLOWS & RULES" section exists in your system prompt, DO NOT call this tool - all necessary guidance is already provided
- Only call this tool if you do NOT see "RELEVANT WORKFLOWS & RULES" in your system prompt and you need additional guidance

CRITICAL - Call ONCE per iteration. Use category array for multiple categories: {"category":["table_operations","error_handling"]}. Reuse result - never call multiple times.

Use when:
- System prompt does NOT contain "RELEVANT WORKFLOWS & RULES" section AND you need general guidance about system operations
- Unsure about table discovery or complex workflows and hints are not already provided
Available categories:
- table_operations → Table creation/update operations (create_tables, update_tables tools)
- field_optimization → General field selection and query optimization (NOT tool-specific)
- database_type → Database-specific context
- error_handling → General error handling protocols
- table_discovery → Finding tables
- complex_workflows → Step-by-step workflows


Input: category (string) or categories (array) or omit for all
Example: {"category":"table_operations"} or {"category":["table_operations","error_handling"]}

Returns:
{
  dbType: string;
  idField: string;
  hints: Array<{category: string; title: string; content: string}>;
  availableCategories: string[];
}`,
    parameters: {
      type: 'object',
      properties: {
        category: {
          oneOf: [
            {
              type: 'string',
              description:
                'Single hint category: database_type, field_optimization, table_operations, error_handling, table_discovery, complex_workflows.',
            },
            {
              type: 'array',
              items: {
                type: 'string',
                enum: ['database_type', 'field_optimization', 'table_operations', 'error_handling', 'table_discovery', 'complex_workflows'],
              },
              description:
                'Multiple hint categories to retrieve at once. Useful when you need guidance on multiple topics (e.g., ["table_operations", "error_handling"]).',
            },
          ],
          description:
            'Hint category (string) or categories (array of strings). Available: database_type, field_optimization, table_operations, error_handling, table_discovery, complex_workflows. Omit for all hints.',
        },
      },
    },
  },
  {
    name: 'create_tables',
    description: `Purpose → Create one or multiple tables. Processes tables sequentially internally to avoid deadlocks.

Inputs:
- tables (required): Array of table definition objects. For single table, use array with 1 element.

Each table object:
- description (optional): Table description
- columns (required): Array of column definition objects. MUST include id column with isPrimary=true. For SQL databases, use type="int". For MongoDB, use type="uuid". Do NOT include createdAt/updatedAt (auto-generated). Do NOT include FK columns (use relations instead).

Column Schema:
{
  name: string; 
  type: "int" | "varchar" | "boolean" | "text" | "date" | "float" | "simple-json" | "enum" | "uuid"; 
  isPrimary?: boolean; 
  isGenerated?: boolean; 
  isNullable?: boolean; 
  default?: any; 
  isUnique?: boolean; 
  description?: string; 
  isHidden?: boolean; 
  isUpdatable?: boolean; 
  isSystem?: boolean; 
  values?: string[]; 
  index?: boolean; 
}

- relations (optional): Array of relation definition objects. Include relations here, not in separate update_tables call.

Relation Schema:
{
  propertyName: string; 
  type: "one-to-one" | "one-to-many" | "many-to-one" | "many-to-many"; 
  targetTable: {id: number}; 
  inversePropertyName?: string; 
  isNullable?: boolean; 
  description?: string; 
  onDelete?: "CASCADE" | "RESTRICT" | "SET NULL"; 
  isEager?: boolean; 
  index?: boolean; 
}

- uniques (optional): Array of unique constraints (e.g., [["slug"], ["email", "username"]])
- indexes (optional): Array of index definitions

Output:
{
  success: boolean;
  total: number;
  succeeded: number;
  failed: number;
  results: Array<{success: boolean; tableName: string; tableId?: number; error?: string; message?: string}>;
  errors?: Array<{index: number; tableName: string; error: string; message: string}>;
  reloadAdminUI: boolean;
  summary: string;
  message: string;
}

Examples:
create_tables({"tables":[{"name":"products","columns":[{"name":"id","type":"int","isPrimary":true,"isGenerated":true},{"name":"name","type":"varchar"}]}]})

Detailed workflows, step-by-step instructions, and validation rules are provided in the "RELEVANT WORKFLOWS & RULES" section of your system prompt if available.`,
    parameters: {
      type: 'object',
      properties: {
        tables: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              description: { type: 'string' },
              columns: { type: 'array', items: { type: 'object' } },
              relations: { type: 'array', items: { type: 'object' } },
              uniques: { type: 'array', items: { type: 'array', items: { type: 'string' } } },
              indexes: { type: 'array', items: { type: 'object' } },
            },
            required: ['name', 'columns'],
          },
        },
      },
      required: ['tables'],
    },
  },
  {
    name: 'update_tables',
    description: `Purpose → Update one or multiple existing tables. Processes tables sequentially internally to avoid deadlocks.

Inputs:
- tables (required): Array of table update objects. For single table, use array with 1 element.

Each table object:
- tableName (required): Table name to update (must exist)
- tableId (optional): Table ID for faster lookup
- description (optional): New table description
- columns (optional): Array of column definition objects to add/update. Merged by name. Schema same as create_tables.
- relations (optional): Array of relation definition objects to add/update. Merged by propertyName. Schema same as create_tables.

**CRITICAL - Relation Update Limitations:**
- You CAN update relation properties: propertyName, targetTable, isNullable, description
- You CANNOT update relation type (many-to-one, one-to-many, one-to-one, many-to-many)
- Relation type is IMMUTABLE - to change type, you MUST delete the existing relation first, then create a new one
- Workflow to change relation type: delete existing relation → create new relation with different type

- uniques (optional): Array of unique constraints (replaces existing)
- indexes (optional): Array of index definitions (replaces existing)

Output:
{
  success: boolean;
  total: number;
  succeeded: number;
  failed: number;
  results: Array<{success: boolean; tableName: string; tableId?: number; updated?: string; error?: string; message?: string}>;
  errors?: Array<{index: number; tableName?: string; tableId?: number; error: string; message: string}>;
  reloadAdminUI: boolean;
  summary: string;
  message: string;
}

Examples:
update_tables({"tables":[{"tableName":"products","columns":[{"name":"stock","type":"int"}]}]})

Detailed workflows and step-by-step instructions are provided in the "RELEVANT WORKFLOWS & RULES" section of your system prompt if available.`,
    parameters: {
      type: 'object',
      properties: {
        tables: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              tableId: { type: 'number' },
              tableName: { type: 'string' },
              description: { type: 'string' },
              columns: { type: 'array', items: { type: 'object' } },
              relations: { type: 'array', items: { type: 'object' } },
              uniques: { type: 'array', items: { type: 'array', items: { type: 'string' } } },
              indexes: { type: 'array', items: { type: 'object' } },
            },
            required: ['tableName'],
          },
        },
      },
      required: ['tables'],
    },
  },
  {
    name: 'delete_tables',
    description: `Purpose → Delete one or multiple tables by their IDs. This tool permanently removes the table structure and all its data. Processes tables sequentially internally.

CRITICAL - Find Table IDs First:
- This tool ONLY accepts table IDs (array of numbers), NOT table names
- BEFORE calling this tool, you MUST find the table IDs first using find_records or get_table_details
- Extract the id(s) (number) from the result and use them in this tool
- NEVER use table name as id - this tool only accepts numeric ids

Inputs:
- ids (required): Array of table IDs (numbers) from table_definition. Must be found first using find_records or get_table_details. For single table, use array with 1 element: [123].

Output:
{
  success: boolean;
  total: number;
  succeeded: number;
  failed: number;
  results: Array<{success: boolean; id: number; name?: string; error?: string; message?: string}>;
  errors?: Array<{index: number; id: number; error: string; message: string}>;
  summary: string;
  message: string;
  reloadAdminUI: boolean;
}

Basic example:
- delete_tables({"ids":[123]})

Detailed workflows and step-by-step instructions are provided in the "RELEVANT WORKFLOWS & RULES" section of your system prompt if available.`,
    parameters: {
      type: 'object',
      properties: {
        ids: {
          type: 'array',
          items: { type: 'number' },
          description: 'Array of table IDs (numbers) from table_definition. Must be found first using find_records({"table":"table_definition","where":{"name":{"_eq":"table_name"}},"fields":"id,name","limit":1}) or get_table_details. For single table, use array with 1 element: [123].',
        },
      },
      required: ['ids'],
    },
  },
  {
    name: 'update_task',
    description: `Purpose → manage task state in conversation.

Use when:
- Starting a new task (create task with status='pending' or 'in_progress')
- Updating task progress (status='in_progress', add data/result)
- Completing task (status='completed' with result)
- Cancelling task (status='cancelled')
- Task failed (status='failed' with error)

CRITICAL - Task Conflict Detection:
- Before creating a new task, check if conversation already has a task with status='pending' or 'in_progress'
- If new task type conflicts with existing task (e.g., create vs delete), cancel existing task first (status='cancelled')
- If new task is continuation of existing task, update existing task instead of creating new one

Task types:
- create_tables: Creating new tables
- update_tables: Updating existing tables
- delete_tables: Deleting tables
- custom: Other custom tasks

Task status flow:
- pending → in_progress → completed/failed/cancelled

Inputs:
- conversationId (required): Current conversation ID
- type (required): Task type (create_tables|update_tables|delete_tables|custom)
- status (required): Task status (pending|in_progress|completed|cancelled|failed)
- data (optional): Task-specific data (e.g., table names, operations)
- result (optional): Task result when completed
- error (optional): Error message when failed
- priority (optional): Task priority (default: 0, higher = more priority)

Returns:
{
  success: boolean;
  task: {
    id: number | string;
    conversationId: number | string;
    type: "create_tables" | "update_tables" | "delete_tables" | "custom";
    status: "pending" | "in_progress" | "completed" | "cancelled" | "failed";
    data?: any;
    result?: any;
    error?: string;
    priority?: number;
    createdAt?: string;
    updatedAt?: string;
  };
}`,
    parameters: {
      type: 'object',
      properties: {
        conversationId: {
          oneOf: [{ type: 'string' }, { type: 'number' }],
        },
        type: {
          type: 'string',
          enum: ['create_tables', 'update_tables', 'delete_tables', 'custom'],
        },
        status: {
          type: 'string',
          enum: ['pending', 'in_progress', 'completed', 'cancelled', 'failed'],
        },
        data: {
          type: 'object',
        },
        result: {
          type: 'object',
        },
        error: {
          type: 'string',
        },
        priority: {
          type: 'number',
          default: 0,
        },
      },
      required: ['conversationId', 'type', 'status'],
    },
  },
  {
    name: 'find_records',
    description: `Purpose → Find/query records in a table, or count records using meta parameter.

CRITICAL - NEVER Select All, ALWAYS Filter and Specify Fields:
- NEVER use "*" or omit fields parameter - ALWAYS specify minimal fields needed (e.g., "id", "id,name")
- NEVER call without where/filter - ALWAYS specify conditions to limit results
- NEVER query all records without filter - ALWAYS use where parameter

Permission: Auto-checked for business tables. Fails with clear error if denied.

CRITICAL - Field Names Check:
- BEFORE using fields parameter: You MUST call get_table_details FIRST to verify field names
- Field names must match exactly (snake_case vs camelCase)

CRITICAL - COUNT Queries (Counting Records):
- To count TOTAL number of records: fields="id", limit=1, meta="totalCount" (omit where or set to null)
- To count records WITH a filter: fields="id", limit=1, where={filter conditions}, meta="filterCount"
- Read the totalCount or filterCount value from the response metadata
- NEVER use limit=0 just to count - always use limit=1 with appropriate meta parameter

Examples:
- Find: find_records({"table":"product","where":{"price":{"_gt":100}},"fields":"id,name","limit":10})
- Count: find_records({"table":"product","fields":"id","limit":1,"meta":"totalCount"})

Detailed workflows, filtering strategies, and best practices are provided in the "RELEVANT WORKFLOWS & RULES" section of your system prompt if available.`,
    parameters: {
      type: 'object',
      properties: {
        table: {
          type: 'string',
          description: 'Name of the table to query.',
        },
        where: {
          type: 'object',
          description:
            'Filter conditions. Supports operators such as _eq,_neq,_gt,_gte,_lt,_lte,_like,_ilike,_contains,_starts_with,_ends_with,_between,_in,_not_in,_is_null,_is_not_null as well as nested logical blocks (_and,_or,_not).',
        },
        fields: {
          type: 'string',
          description:
            'REQUIRED. Fields to return. Use get_table_details for available fields, then specify ONLY needed fields (e.g., "id" for count, "id,name" for list). Supports wildcards like "columns.*", "relations.*". CRITICAL: NEVER use "*" or omit fields parameter - this returns all fields and wastes tokens. ALWAYS specify minimal fields needed.',
        },
        limit: {
          type: 'number',
          description:
            'Max records to return. 0 = no limit (fetch all), > 0 = specified number. Default: 10. For counting, use limit=1 with meta parameter.',
        },
        sort: {
          type: 'string',
          description:
            'Sort field(s). Format: "fieldName" (ascending) or "-fieldName" (descending). Multi-field: comma-separated, e.g., "name,-createdAt". Examples: "createdAt", "-createdAt", "name,-price". Default: "id".',
        },
        meta: {
          type: 'string',
          enum: ['totalCount', 'filterCount'],
          description:
            'Optional. For counting records: "totalCount" to count all records (no filter), "filterCount" to count records matching filter. MUST use with limit=1 and fields="id". The count will be returned in response metadata.',
        },
      },
      required: ['table', 'fields'],
    },
  },
  {
    name: 'create_records',
    description: `Purpose → Create one or multiple records in a table. Processes records sequentially internally.

Permission: Auto-checked for business tables. Fails with clear error if denied.

CRITICAL - Schema Check Required:
- BEFORE create operations: You MUST call get_table_details FIRST to check the table schema
- Schema check ensures: all required fields included, column names match, relations format correct, data types match

CRITICAL - Check Unique Constraints Before Create:
- BEFORE create operations: You MUST check if records with unique field values already exist using find_records
- If record exists, skip creation or use update_records instead - duplicate unique values will cause errors

CRITICAL - Relations Format:
- For relations: Use propertyName from get_table_details result.relations[] with the ID value directly
- Format: {"propertyName": <id_value>} where propertyName is from relations[].propertyName
- Example: If relation has propertyName="customer", use {"customer": 1} NOT {"customer_id": 1}

CRITICAL - DO NOT Include ID in Create Operations:
- NEVER include "id" field in data - including id will cause errors

Inputs:
- table (required): Name of the table to create records in
- dataArray (required): Array of data objects. For single record, use array with 1 element. DO NOT include "id" field in any data object.
- fields (optional): Fields to return. ALWAYS specify minimal fields (e.g., "id" or "id,name") to save tokens.

Output:
{
  success: boolean;
  total: number;
  succeeded: number;
  failed: number;
  results: Array<{success: boolean; index: number; id?: number; error?: string; message?: string}>;
  errors?: Array<{index: number; error: string; message: string; data?: any}>;
  summary: string;
  message: string;
}

Examples:
create_records({"table":"product","dataArray":[{"name":"Laptop","price":999.99}],"fields":"id"})

Detailed workflows, step-by-step instructions, and best practices are provided in the "RELEVANT WORKFLOWS & RULES" section of your system prompt if available.`,
    parameters: {
      type: 'object',
      properties: {
        table: {
          type: 'string',
          description: 'Name of the table to create records in.',
        },
        dataArray: {
          type: 'array',
          items: {
            type: 'object',
          },
          description: 'Array of data objects for new records. CRITICAL: DO NOT include "id" field in any data object.',
        },
        fields: {
          type: 'string',
          description:
            'Fields to return. ALWAYS specify minimal fields (e.g., "id" or "id,name") to save tokens. Do NOT use "*" or omit fields parameter - this returns all fields and wastes tokens.',
        },
      },
      required: ['table', 'dataArray'],
    },
  },
  {
    name: 'update_records',
    description: `Purpose → Update one or multiple records by ID. Processes records sequentially internally.

Permission: Auto-checked for business tables. Fails with clear error if denied.

CRITICAL - Schema Check Required:
- BEFORE update operations: You MUST call get_table_details FIRST to check the table schema
- Schema check ensures: column names match, relations format correct, data types match

CRITICAL - Check Record Exists Before Update:
- BEFORE update operations: You MUST check if the record exists using find_records
- If record does not exist, skip update or report error

CRITICAL - Relations Format:
- For relations: Use propertyName from get_table_details result.relations[] with the ID value directly
- Format: {"propertyName": <id_value>} where propertyName is from relations[].propertyName
- Example: If relation has propertyName="customer", use {"customer": 1} NOT {"customer_id": 1}

Inputs:
- table (required): Name of the table to update records in
- updates (required): Array of update objects. For single record, use array with 1 element. Each object: {id: number|string, data: object}
- fields (optional): Fields to return. ALWAYS specify minimal fields (e.g., "id" or "id,name") to save tokens.

Output:
{
  success: boolean;
  total: number;
  succeeded: number;
  failed: number;
  results: Array<{success: boolean; index: number; id?: number|string; error?: string; message?: string}>;
  errors?: Array<{index: number; id?: number|string; error: string; message: string}>;
  summary: string;
  message: string;
}

Examples:
update_records({"table":"product","updates":[{"id":1,"data":{"price":899.99}}],"fields":"id"})

Detailed workflows, step-by-step instructions, and best practices are provided in the "RELEVANT WORKFLOWS & RULES" section of your system prompt if available.`,
    parameters: {
      type: 'object',
      properties: {
        table: {
          type: 'string',
          description: 'Name of the table to update records in.',
        },
        updates: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: {
                oneOf: [{ type: 'string' }, { type: 'number' }],
              },
              data: {
                type: 'object',
              },
            },
            required: ['id', 'data'],
          },
          description: 'Array of update objects. Each object: {id: number|string, data: object}',
        },
        fields: {
          type: 'string',
          description:
            'Fields to return. ALWAYS specify minimal fields (e.g., "id" or "id,name") to save tokens. Do NOT use "*" or omit fields parameter - this returns all fields and wastes tokens.',
        },
      },
      required: ['table', 'updates'],
    },
  },
  {
    name: 'delete_records',
    description: `Purpose → Delete one or multiple records by ID. Processes records sequentially internally.

Permission: Auto-checked for business tables. Fails with clear error if denied.

CRITICAL - Check Record Exists Before Delete:
- BEFORE delete operations: You MUST check if the record exists using find_records
- If record does not exist, skip delete or report error

CRITICAL - Deleting Tables (NOT Data):
- To DELETE/DROP/REMOVE a TABLE (not data records), you MUST use the delete_tables tool
- NEVER use delete_records to delete tables - use delete_tables tool instead
- NEVER use delete_records on data tables to delete tables - this only deletes data records, not the table itself

Inputs:
- table (required): Name of the table to delete records from
- ids (required): Array of record IDs. For single record, use array with 1 element.

Output:
{
  success: boolean;
  total: number;
  succeeded: number;
  failed: number;
  results: Array<{success: boolean; index: number; id?: number|string; error?: string; message?: string}>;
  errors?: Array<{index: number; id?: number|string; error: string; message: string}>;
  summary: string;
  message: string;
}

Examples:
delete_records({"table":"product","ids":[1]})

Detailed workflows and best practices are provided in the "RELEVANT WORKFLOWS & RULES" section of your system prompt if available.`,
    parameters: {
      type: 'object',
      properties: {
        table: {
          type: 'string',
          description: 'Name of the table to delete records from.',
        },
        ids: {
          type: 'array',
          items: {
            oneOf: [{ type: 'string' }, { type: 'number' }],
          },
          description: 'Array of record IDs to delete.',
        },
      },
      required: ['table', 'ids'],
    },
  },
];

function toAnthropicFormat(tools: ToolDefinition[]) {
  return tools.map((tool) => ({
    name: tool.name,
    description: tool.description,
    input_schema: tool.parameters,
  }));
}

function toOpenAIFormat(tools: ToolDefinition[]) {
  return tools.map((tool) => ({
    type: 'function' as const,
    function: {
      name: tool.name,
      description: tool.description,
      parameters: tool.parameters,
    },
  }));
}

export function getTools(provider: string = 'OpenAI') {
  if (provider === 'Anthropic') {
    return toAnthropicFormat(COMMON_TOOLS);
  }
  return toOpenAIFormat(COMMON_TOOLS);
}

